<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中的字符串类</title>
      <link href="/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
      <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="String-不可变的字符串"><a href="#String-不可变的字符串" class="headerlink" title="String 不可变的字符串"></a>String 不可变的字符串</h2><p>String类部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="comment">// 可序列化</span></span><br><span class="line">    <span class="comment">// 可比较大小</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  <span class="comment">//数组元素不可修改（final）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>String类被定义成final,不能被扩展，也不需要被扩展（定义的方法很全）。</li><li>用char数组来存储，并定义成final，<strong>不可变</strong>。</li><li>对字符串操作，不改变原字符串，都是new String()。</li></ul><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209231515205.png" alt="image-20220421094420345" style="zoom:67%;" /><p>intern():如果字符串常量池中包含一个等于String对象的字符串（通过equals()）,则返回池中的字符串，否则，将String对象添加到池中，并返回该对象的引用。由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为真时，s.intern() == t.intern() 才为真。</p><h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>StringBuilder部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence&#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保存数据的char数组并未被定义成final</li><li>可变字符序列</li></ul><blockquote><ul><li>String是不可变字符序列，而StringBuffer，StringBuilder都是可变字符序列</li><li>String可以通过字面量方式赋值，StringBuffer/StringBuilder只能是通过构造器 new</li><li>StringBuffer线程安全，效率低（里面的方法都是synchronized,同步方法），而StringBuilder线程不安全的，效率高</li></ul></blockquote><p>三者底层都是使用char[]数组进行存储，那如何实现可变和不可变？</p><blockquote><p><code>String s=new String()</code> //new char[0],长度为0</p><p><code>String s=new String(&quot;abc&quot;)</code> //new char[3]{‘a’,’b’,’c’}</p><p><code>StringBuffer buffer=new StringBuffer()</code>// new char[capacity]   capacity=16</p><p><code>StringBuffer buffer1=new StringBuffer(&quot;abc&quot;)</code>// new char[s.length()+capacity]   capacity=16  capacity+s.length()作为初始容量，然后调用buffer.append()   （看一下如何进行扩容）</p><p>问题1：此时buffer1.length()  是3    //append()后count+buffer1.length()返回count的值，而不是数组的容量</p><p>问题2：char数组如何进行扩容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;   <span class="comment">//确保容量是够的</span></span><br><span class="line">  <span class="comment">// minimumCapacity是count+append的字符长度</span></span><br><span class="line"> <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;<span class="comment">//大于数组长度，不够了，需要扩容</span></span><br><span class="line">     value = Arrays.copyOf(value,</span><br><span class="line">                           newCapacity(minimumCapacity));<span class="comment">//默认下，扩充的容量是2倍的value+2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果append次数很多，频繁扩容，扩容要复制一份，影响效率，所以可以使用<code>StringBuffer(int capacity)</code>构造器,指定容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟 String做对比</span></span><br><span class="line">StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">buffer.setCharAt(<span class="number">1</span>,<span class="string">&#x27;m&#x27;</span>);<span class="comment">//void方法，没有返回值</span></span><br><span class="line">System.out.println(buffer);<span class="comment">//amc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串不可变性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2022/09/20/Git/"/>
      <url>/2022/09/20/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="git概念"><a href="#git概念" class="headerlink" title="git概念"></a>git概念</h1><p><strong>集中式版本控制工具</strong></p><p>SVM,CVS,有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><p><strong>缺点：</strong>中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作</p><p><strong>分布式版本控制工具</strong></p><p>git  每个人在本地进行版本控制，然后push到远程仓库，即使远程仓库发生故障，也可以在本地进行版本控制，只不过在远程仓库宕机的这段时间，不能进行push.</p><p><strong>基本概念</strong></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918162605598.png" alt="image-20220918162605598"></p><ul><li>工作区—-git add—– 暂存区—–git commit—–本地库</li></ul><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p><strong>全局配置</strong></p><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git config –list</td><td></td></tr></tbody></table><p><strong>获取git仓库</strong></p><ul><li>通过 git init 命令初始化本地仓库</li><li>从远程仓库克隆（常用） git clone 远程仓库地址</li></ul><hr><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名/*</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset –hard 版本号<br>git reset 文件名</td><td>版本穿梭<br>将暂存区的文件取消暂存</td></tr></tbody></table><p>安装时，默认创建master分支</p><p>暂存区文件可以删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cache 文件名</span><br></pre></td></tr></table></figure><p>查看版本的详细信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>查看版本的精简信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h1 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h1><blockquote><p>思考：为什么要创建不同分支？</p><p>同一个仓库，可以有多个分支，每一个分支文件可以不同</p></blockquote><p><strong>分支命令</strong></p><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch  <br>git branch -r<br>git branch -a</td><td>查看本地仓库分支<br>列出所有远程仓库分支<br>列出本地和远程仓库分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 指定分支名</td><td>将指定的分支合并到当前分支上</td></tr></tbody></table><p><strong>正常合并分支</strong></p><p>在当前分支上，将指定分支合并到当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 指定分支</span><br></pre></td></tr></table></figure><p><strong>冲突合并分支</strong></p><p>【两个分支下都有同一个文件，做不同修改，合并就会发生冲突】</p><ul><li>在master分支上对代码进行修改，并提交到本地库</li></ul><p><img src="F:\截图\94.png" alt="94"></p><ul><li>在hot-fix分支上对代码进行修改，并提交到本地库</li></ul><p><img src="F:\截图\95.png" alt="95"></p><ul><li>这时候合并就会发生冲突</li></ul><p><img src="F:\截图\96.png" alt="96"></p><ul><li>需要人为决定新代码的内容，添加到暂存区【也就是告诉git已手动解决完冲突】，提交到本地库【**注意：这时git commit命令==不要带文件名==**】</li></ul><p><img src="F:\截图\97.png" alt="97"></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918200526288.png" alt="image-20220918200526288"></p><h1 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h1><p><strong>远程仓库操作命令</strong></p><table><thead><tr><th><strong>命令名称</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前本地仓库所关联的远程地址及其别名</td></tr><tr><td>git remote add &lt;别名&gt; 远程地址</td><td>添加远程仓库，使其与本地仓库添加关联</td></tr><tr><td>git push [remote_name] [branch_name]</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程仓库地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull [remote_name] [branch_name]</td><td>从远程仓库获取最新版本，并合并到本地仓库</td></tr></tbody></table><ul><li>添加远程仓库地址，并查看所有远程地址的别名</li></ul><p><img src="F:\截图\98.png" alt="98"></p><p>前面是别名，后面是具体的远程仓库地址</p><ul><li>推送本地分支到远程仓库【要指定本地仓库的哪个分支】</li></ul><p><img src="F:\截图\99.png" alt="99"></p><ul><li>拉取远程库内容到本地库【保证远程库的代码和本地库的代码同步】</li></ul><p><img src="F:\截图\100.png" alt="100"></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918172038065.png" alt="image-20220918172038065"></p><ul><li>克隆远程仓库到本地库</li></ul><p><img src="F:\截图\101.png" alt="101"></p><p>克隆会做以下三件事： ①拉取代码  ②初始化本地仓库 ③给远程仓库地址起别名origin</p><h1 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h1><p>git中的标签是指某个分支某个特定时间点的状态【就像照片一样，已经定格，里面内容就不再变化，不像分支，可以不断增加修改】。通过标签可以方便切换到标记的状态。</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>git tag</td><td>列出所有已有标签</td></tr><tr><td>git tag [name]</td><td>创建标签</td></tr><tr><td>git push [short_name] [name]</td><td>将标签推送至远程仓库</td></tr><tr><td>git checkout -b [branch] [name]</td><td>需要创建新的分支来指向某个标签，该分支上的代码就是被标记时的状态</td></tr></tbody></table><h1 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h1><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918204046772.png" alt="image-20220918204046772"></p><p>.gitignore就记录了当前仓库的哪些内容不需要被git管理</p><p><strong>忽略一些特定文件</strong></p><ul><li>创建忽略文件Xxx.ignore(建议名称为git.ignore),建议将该文件放在用户家目录下</li></ul><p>git.ignore文件的模板</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><ul><li>在.gitconfig文件【此文件在Windows的家目录中】中引用忽略配置文件</li></ul><p><img src="F:\截图\102.png" alt="102"></p><p><strong>将文件加入暂存区</strong></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918205143649.png" alt="image-20220918205143649"></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918205634985.png" alt="image-20220918205634985"></p><p><strong>查看远程仓库</strong></p><p>也可以添加远程仓库，可以对应多个远程仓库；删除，只是删除与远程仓库的关联，而不是把远程仓库删掉</p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918210345417.png" alt="image-20220918210345417"></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918210550028.png" alt="image-20220918210550028"></p><p><strong>分支操作</strong></p><p><img src="C:\Users\shatianhui\AppData\Roaming\Typora\typora-user-images\image-20220918211151822.png" alt="image-20220918211151822"></p><blockquote><p>注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高！因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要<strong>先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送</strong>！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
