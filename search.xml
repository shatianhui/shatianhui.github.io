<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法(一）</title>
      <link href="/2022/10/05/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>/2022/10/05/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056927.png" alt="image-20220930111729075"></p><p>父结点索引 i/2</p><p>左孩子结点索引  2*i  右孩子结点索引2<code>*</code>i</p><p>最大堆：每个结点都大于等于它的两个左右子结点</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>功能：插入和删除元素，元素会自动排序。底层二叉树操作</p><p>最大优先级队列代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123; <span class="comment">// Key是任何一种可比较大小的数据类型</span></span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">        <span class="comment">//先插入到堆底，然后上浮</span></span><br><span class="line">        size++;</span><br><span class="line">        pq[size]=e;</span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        Key max=pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把最大元素放到最后，并删除</span></span><br><span class="line">        swap(<span class="number">1</span>,size);</span><br><span class="line">        pq[size]=<span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 调整堆</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span> &amp;&amp; less(parent(x),x))&#123; <span class="comment">//当前结点比父结点大</span></span><br><span class="line">            swap(parent(x),x);</span><br><span class="line">            x=parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="comment">// 下沉某个结点，需要该结点和其左右子节点比较，如果该结点不是最大的，就和较大的子节点交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 直到到堆底</span></span><br><span class="line">        <span class="keyword">while</span>(left(x) &lt;=size)&#123;</span><br><span class="line">            <span class="type">int</span> max=left(x); <span class="comment">//记录左右子节点较大的那个</span></span><br><span class="line">            <span class="keyword">if</span>(right(x)&gt;=size &amp;&amp; less(max,right(x)))&#123; <span class="comment">// 右结点一定要存在</span></span><br><span class="line">                max=right(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(less(max,x))&#123;  <span class="comment">//当前结点比左右结点大，不必下沉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(max,x);</span><br><span class="line">            x=max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 左孩子结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 右孩子结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java优先级队列实现类 PriorityQueue</p><h1 id="常数时间删除-查找数组中的任意元素"><a href="#常数时间删除-查找数组中的任意元素" class="headerlink" title="常数时间删除/查找数组中的任意元素"></a>常数时间删除/查找数组中的任意元素</h1><p>力扣第 380 题「 <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">常数时间插入、删除和获取随机元素</a>」</p><p>本题的难点在于两点：</p><p>**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。</p><p><strong>2、<code>getRandom</code> 方法返回的元素必须等概率返回随机元素</strong>，也就是说，如果集合里面有 <code>n</code> 个元素，每个元素被返回的概率必须是 <code>1/n</code></p><p>HashSet可以实现O(1)内插入，删除，但无法等概率返回随机元素</p><p>对于 <code>getRandom</code> 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：<strong>底层用数组实现，且数组必须是紧凑的</strong>。</p><p>用数组（List），插入删除操作O(1),就不能移动元素，使用HashMap记录元素与索引之间的关系。</p><p>最麻烦的应该是删除操作：更新map,最后一个元素直接删除，不是最后一个，和最后一个元素交换</p><p><strong>疑问：</strong>remove()方法有根据索引的，有根据值的，下面是根据索引还是值？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list); 【<span class="number">1</span>，<span class="number">2</span>】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是根据索引删除的，并没有根据值</p><p>力扣第 710 题「 <a href="https://leetcode.cn/problems/random-pick-with-blacklist/">黑名单中的随机数</a>」</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056245.png" alt="image-20221002114805505"></p><p>随机生成一个[0,sz), 如果生成的数在黑名单上，映射到sz后面的数</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>单调栈用于解决一类题，解决<code>下一类更大元素的问题</code></p><p>eg:一个数组 <code>nums = [2,1,2,4,3]</code>，返回结果 <code>[4,2,4,-1,-1]</code>。</p><p>暴力解法：O(n^2)  单调栈：O(n)</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056732.png" alt="image-20221005100932499"></p><p>算法模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的更大元素</span></span><br><span class="line">        res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题</p><p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></p><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></p><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>第一类题： 数组原地去重  –&gt;   使用快慢指针</p><p>316 题「 <a href="https://leetcode.cn/problems/remove-duplicate-letters/">去除重复字母</a>」</p><p>该题：要求返回的结果字典序最小</p><p>利用栈</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先级队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索</title>
      <link href="/2022/09/30/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/09/30/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>没有重复元素的有序数组  普通二分查找</p><p>重复元素的有序数组  左侧边界的二分搜索，右侧边界的二分搜索</p><p><strong>左侧边界的二分搜索</strong></p><p>当target存在数组nums中时，返回的是第一个重复元素的索引</p><p>当target不存在数组nums中时</p><p>例：nums[]=[2,3,5,7]  target=4    返回的left=2</p><ul><li>left指向nums中大于target的最小元素索引</li><li>返回的是target应该插入的位置索引</li><li>返回nums数组中小于target的个数</li></ul><p><strong>右侧边界的二分搜索</strong></p><p>返回的是最后一个重复元素的索引</p><h1 id="二分搜索的应用"><a href="#二分搜索的应用" class="headerlink" title="二分搜索的应用"></a>二分搜索的应用</h1><p>什么问题可以应用二分搜索？</p><ul><li><input checked="" disabled="" type="checkbox"> 从题目中抽象出一个自变量 x，一个关于 x的函数 f(x)，以及一个目标值 target。</li></ul><p>同时，x, f(x), target 还要满足以下条件：</p><ol><li>f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。</li><li>题目是让你计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值。</li></ol><p>例：<a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p><p>分析：自变量x是珂珂吃香蕉的速度，f(x)是吃完所有堆上所用时间。 x越大，吃的越快，所花时间f(x)就越小。吃香蕉的时间限制H就是target.</p><p>x的左右边界如何确定？ 最小速度=1 最大速度堆上最大的香蕉个数  使用左侧边界的二分搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=maxV(piles);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(f(piles,mid)==h)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(piles,mid)&lt;h)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(piles,mid)&gt;h)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 速度为x时，吃完所有堆所需时间  递减可重复的有序序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> x)</span>&#123;   <span class="comment">// int类型不够</span></span><br><span class="line">        <span class="type">long</span> hours=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;piles.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]%x==<span class="number">0</span>)&#123;</span><br><span class="line">                hours+=piles[i]/x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hours=hours+<span class="number">1</span>+piles[i]/x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求堆中最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxV</span><span class="params">(<span class="type">int</span>[] piles)</span>&#123;</span><br><span class="line">        <span class="type">int</span> max=piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;piles.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]&gt;max)&#123;</span><br><span class="line">                max=piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p><p>自变量x为船载重，f(x)为所有包裹送达所需时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 45讲（二）</title>
      <link href="/2022/09/29/MySql45%E8%AE%B2(2)/"/>
      <url>/2022/09/29/MySql45%E8%AE%B2(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><p>数据库原本c的值为1</p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20220928113353148.png" alt="image-20220928113353148" style="zoom:50%;" /><p>不同隔离级别的结果</p><ul><li><p>隔离级别为<strong>读未提交</strong>（read uncommitted）:一个事务还没提交时，它的事务就能被别的事务所看见。</p><p>事务B未提交，但结果已经被事务A所看见。 V1=2 V2=2 V3=2</p></li><li><p>隔离级别为<strong>读提交</strong>（read committed）:一个事务提交之后，它的结果才能被其他事务所看见。</p><p>V1=1 V2=2 V3=2</p></li><li><p>隔离级别为<strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是和这个事务在启动时看到的一样。并且，未提交的变更对其他事务也是不可见的。</p><p>V1=1 V2=1 V3=2</p></li><li><p>隔离级别为<strong>串行化</strong>（serializable）:对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p>在事务B将1改成2时锁住，直到事务A执行完成,事务B才能继续执行。 V1=1 V2=1 V3=2</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 45讲（一）</title>
      <link href="/2022/09/27/MySql45%E8%AE%B2(1)/"/>
      <url>/2022/09/27/MySql45%E8%AE%B2(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="一条SQL查询语句的执行流程"><a href="#一条SQL查询语句的执行流程" class="headerlink" title="一条SQL查询语句的执行流程"></a>一条SQL查询语句的执行流程</h1><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615720.png" alt="image-20220927150319024"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。</li></ul><p>长连接 &amp; 短连接</p><p><strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p><p><strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。但<strong>查询缓存的失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。MySQL 8.0版本无查询缓存功能。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器先会做“词法分析”。MySQL需要识别出SQL语句的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>如下面这条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><h1 id="一条SQL更新语句的执行流程"><a href="#一条SQL更新语句的执行流程" class="headerlink" title="一条SQL更新语句的执行流程"></a>一条SQL更新语句的执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>更新流程涉及两个重要的日志模块。redo log（重做日志）和 binlog（归档日志）</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>WAL（Write_Ahead Logging）技术: 先写日志，再写磁盘。</p><p>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p><p>InnoDB的redo log是固定大小的</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615895.png" alt="image-20220927154602131"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>两种日志的不同</p><ul><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615765.png" alt="image-20220927155212268"></p><p>redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>]]></content>
      
      
      <categories>
          
          <category> mysql高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL执行流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结构</title>
      <link href="/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><p><strong>二叉排序树</strong>，缺陷：在极端情况下，一个有序序列会退化成链表</p><p>所以，要使用<strong>平衡树</strong>来进行调节</p><p>为什么要保证树的平衡？ 因为树的查询效率取决于树的高度，让树尽可能的平衡，就是为了减少树的高度。</p><p>那<strong>B树</strong>的作用是什么？</p><p>B树又叫多路查找树，每个结点可以拥有多于两个孩子结点。m路B树最多就可以拥有m个孩子结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714106.png" alt="image-20220925162730234"></p><p>这是棵三路B树。为什么要设计成多路？就是为了进一步降低树的高度。路数越多，树就越低。那路数无限大，不就更好？</p><p>为什么文件系统的索引使用B树，而不使用红黑树或者是有序数组？</p><p>文件系统或者数据库的索引是存储在硬盘上的，如果数据量越大，就不能一次性的加载到内存。这时候，能够体现B树的多路存储作用，每次加载B树的一个结点，然后一步一步往下找。</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714091.png" alt="image-20220925163551755"></p><p>假设内存一次性只能加载两个树，这时候有序数组【25，25，30，40，43，45，50，59，65，77，85】是不能够一次性加载到内存的，所以，可以构建三路B树，每个结点至多有两个数。</p><p>那<strong>B+树</strong>有什么作用？</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714422.png" alt="image-20220925164941429"></p><p>这是一棵4路B+树，<strong>数据都在叶子结点，并且通过链表相连</strong>。</p><p>使用场景：比如select查询多条数据，B树可能需要做中序遍历，跨层访问，而B+树所有的数据都在叶子结点，同时拥有链表结构，只需要找到首尾，就可以把所有数据取出来。</p><p>mysql存储索引使用的是B+树。</p><p>B+树查询效率与树的高度有关，O(logn),而hash查询索引效率O(1),hash比B+树更快，为什么要用B+树，而不用hash?</p><p>1.只查询一个数据，确实是hash更快，单数据库经常查询的是多条数据，这时候B+树索引有序，又有链表相连，查询效率要比hash快很多。2.前面提到，数据库索引一般存储在磁盘，如果数据量大，一次可能无法装入内存，B+树可以分批加载，树的高度越低，可以提高查询效率。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉排序树 </tag>
            
            <tag> AVL </tag>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文系列</title>
      <link href="/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/"/>
      <url>/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ul><li>寻找回文串  –&gt; 双指针从两端向中间逼近</li><li>寻找一个字符串中最大回文串  –&gt; 寻找以s[left]和s[right]为中心的最长回文串  （中间向两端逼近）</li></ul><h1 id="判断回文单链表"><a href="#判断回文单链表" class="headerlink" title="判断回文单链表"></a>判断回文单链表</h1><p>思路1：将单链表的值放到数组中，然后通过数组来判断</p><p>思路2：反转单链表，判断两个链表是否完全相同</p><p>思路3：利用二叉树后序遍历思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ListNode left=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法1：将单链表反转成新的链表</span></span><br><span class="line">    <span class="comment">// 方法2：将单链表的值放到数组中，通过数组来判断</span></span><br><span class="line">    <span class="comment">// 方法3：利用二叉树后续遍历思路</span></span><br><span class="line">    left=head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(ListNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> res= traverse(right.next);</span><br><span class="line">    res=res &amp;&amp; left.val==right.val;</span><br><span class="line">    left=left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路4：优化空间复杂度</p><ul><li>先找到链表的中点     使用快慢指针</li><li>反转后半部分链表  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法1：将单链表反转成新的链表</span></span><br><span class="line">    <span class="comment">// 方法2：将单链表的值放到数组中，通过数组来判断</span></span><br><span class="line">    <span class="comment">// 方法3：利用二叉树后续遍历思路</span></span><br><span class="line">    <span class="comment">// 方法4：寻找链表的中间结点，将链表的后半段翻转</span></span><br><span class="line">    ListNode slow=head; ListNode fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast!=<span class="literal">null</span>)&#123;  <span class="comment">//链表的结点个数是奇数</span></span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode right=reverse(slow);</span><br><span class="line">    ListNode left=head;</span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=left.next;</span><br><span class="line">        right=right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode slow)</span>&#123;</span><br><span class="line">    ListNode pre=<span class="literal">null</span>;</span><br><span class="line">    ListNode cur=slow;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode s=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>如何反转单链表？ <a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></p><ol><li><p>依靠栈</p></li><li><p>头插法，把原链表一个一个摘下，插入到新链表前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p=head.next;</span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode s=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">        s.next=pre;</span><br><span class="line">        pre=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p></li></ol><blockquote><p>递归的空间复杂度为O(N),而迭代的时间复杂度为O(1).</p></blockquote><h2 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h2><p><strong>==递归最重要的就是明确递归函数的含义==</strong></p><p>ListNode reverse(ListNode head) // 输入单链表头结点，将该头结点的整个链表反转，返回新的头结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251122515.png" alt="image-20220925112218962"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=ReverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方式，代码简洁优雅</p><h2 id="递归反转部分链表"><a href="#递归反转部分链表" class="headerlink" title="递归反转部分链表"></a>递归反转部分链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p><p>reverseBetween(ListNode head, int left, int right) //输入单链表头结点，将链表的第left结点到第right结点反转，返回新链表的头结点</p><p>首先，考虑如何反转前n个结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251152986.png" alt="image-20220925115211597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor=<span class="literal">null</span>; </span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head，<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        successor=head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=reverseN(head.next,n-<span class="number">1</span>);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：递归反转部分链表</p><p>left=1 就想当于反转前n个结点</p><p>left!=1 前进到反转的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a>k个一组反转链表</h2><p>递归解决</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271024508.png" alt="image-20220927102415994"></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文串 </tag>
            
            <tag> 反转链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法</title>
      <link href="/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    HashMap&lt;<span class="type">int</span>,<span class="type">char</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>; <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;s.length)&#123;</span><br><span class="line">        <span class="comment">// 将该字符移入窗口</span></span><br><span class="line">        <span class="type">char</span> c=s[right];</span><br><span class="line">        right++; <span class="comment">//增大窗口</span></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">    <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：力扣第 76 题「 <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>」</p><p>思路：</p><ol><li>初始化左右指针left=right=0; 把[left,right) 左闭右开，作为窗口</li><li>不断增大right指针，直到窗口中的字符串符合要求（包含T中所有字符），停止增加right  ——&gt;寻找可行解</li><li>增大left指针，缩小窗口，直到窗口的字符串不再符合要求（不包含T中所有字符），停止增加left –&gt;这个可行解的最优解</li><li>重复第2第3步，直到right到达字符串的尽头  –&gt;最优解</li></ol><p>HashMap中记录窗口中的字符和需要凑齐的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录目标字符串，每个字符及对应需要的个数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need.get(t.charAt(i))==<span class="literal">null</span>)&#123;</span><br><span class="line">                need.put(t.charAt(i),<span class="number">1</span>);</span><br><span class="line">                window.put(t.charAt(i),<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                need.put(t.charAt(i),need.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;<span class="comment">//窗口需要满足的字符个数</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;<span class="type">int</span> end=s.length()+<span class="number">1</span>;  <span class="comment">// 记录最优字符的起始位置</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">char</span> c= s.charAt(right); <span class="comment">//加入窗口</span></span><br><span class="line">             right++;  <span class="comment">//扩大窗口</span></span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">                window.put(c,window.get(c)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(window.get(c).equals(need.get(c)))&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(valid==need.size())&#123; </span><br><span class="line">                <span class="comment">// 寻找可行解的最优解</span></span><br><span class="line">                <span class="keyword">if</span>(end-start&gt;right-left)&#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    end=right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d=s.charAt(left); <span class="comment">//移除窗口</span></span><br><span class="line">                left++;  <span class="comment">//缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(window.containsKey(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window.get(d).equals(need.get(d)))&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end-start==s.length()+<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 语言处理字符串还是有点麻烦的，一直使用charAt(i)  没有使用索引s[i]方便</p><p>同类型练习题</p><p>力扣第 567 题「 <a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>」   维护的滑动窗口定长</p><p>力扣第 438 题「 <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>」</p><p>力扣第 3 题「 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>」 </p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的字符串类</title>
      <link href="/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
      <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="String-不可变的字符串"><a href="#String-不可变的字符串" class="headerlink" title="String 不可变的字符串"></a>String 不可变的字符串</h2><p>String类部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="comment">// 可序列化</span></span><br><span class="line">    <span class="comment">// 可比较大小</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  <span class="comment">//数组元素不可修改（final）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>String类被定义成final,不能被扩展，也不需要被扩展（定义的方法很全）。</li><li>用char数组来存储，并定义成final，<strong>不可变</strong>。</li><li>对字符串操作，不改变原字符串，都是new String()。</li></ul><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209231515205.png" alt="image-20220421094420345" style="zoom:67%;" /><p>intern():如果字符串常量池中包含一个等于String对象的字符串（通过equals()）,则返回池中的字符串，否则，将String对象添加到池中，并返回该对象的引用。由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为真时，s.intern() == t.intern() 才为真。</p><h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>StringBuilder部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence&#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保存数据的char数组并未被定义成final</li><li>可变字符序列</li></ul><blockquote><ul><li>String是不可变字符序列，而StringBuffer，StringBuilder都是可变字符序列</li><li>String可以通过字面量方式赋值，StringBuffer/StringBuilder只能是通过构造器 new</li><li>StringBuffer线程安全，效率低（里面的方法都是synchronized,同步方法），而StringBuilder线程不安全的，效率高</li></ul></blockquote><p>三者底层都是使用char[]数组进行存储，那如何实现可变和不可变？</p><blockquote><p><code>String s=new String()</code> //new char[0],长度为0</p><p><code>String s=new String(&quot;abc&quot;)</code> //new char[3]{‘a’,’b’,’c’}</p><p><code>StringBuffer buffer=new StringBuffer()</code>// new char[capacity]   capacity=16</p><p><code>StringBuffer buffer1=new StringBuffer(&quot;abc&quot;)</code>// new char[s.length()+capacity]   capacity=16  capacity+s.length()作为初始容量，然后调用buffer.append()   （看一下如何进行扩容）</p><p>问题1：此时buffer1.length()  是3    //append()后count+buffer1.length()返回count的值，而不是数组的容量</p><p>问题2：char数组如何进行扩容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;   <span class="comment">//确保容量是够的</span></span><br><span class="line">  <span class="comment">// minimumCapacity是count+append的字符长度</span></span><br><span class="line"> <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;<span class="comment">//大于数组长度，不够了，需要扩容</span></span><br><span class="line">     value = Arrays.copyOf(value,</span><br><span class="line">                           newCapacity(minimumCapacity));<span class="comment">//默认下，扩充的容量是2倍的value+2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果append次数很多，频繁扩容，扩容要复制一份，影响效率，所以可以使用<code>StringBuffer(int capacity)</code>构造器,指定容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟 String做对比</span></span><br><span class="line">StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">buffer.setCharAt(<span class="number">1</span>,<span class="string">&#x27;m&#x27;</span>);<span class="comment">//void方法，没有返回值</span></span><br><span class="line">System.out.println(buffer);<span class="comment">//amc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串不可变性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
