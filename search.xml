<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回溯算法&amp;图</title>
      <link href="/2022/11/02/%E5%9B%BE%E7%AE%97%E6%B3%95%E5%8F%8Adfs/"/>
      <url>/2022/11/02/%E5%9B%BE%E7%AE%97%E6%B3%95%E5%8F%8Adfs/</url>
      
        <content type="html"><![CDATA[<h1 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h1><p>图的存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; graph[]=<span class="keyword">new</span> <span class="title class_">List</span>[numCourses];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">graph[i]=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，图的遍历和树的遍历的区别</p><p>图存在环，从一个节点遍历可能会走到自身；而树从一个节点出发，一定会走到叶子节点，所以遍历图需要辅助数组visited来记录是否被访问过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Graph graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//----前序遍历位置----</span></span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph.neighbors(s)) &#123;</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//----后序遍历位置-------</span></span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//----------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图遍历与回溯算法的比较</strong></p><blockquote><p>回溯算法做选择是在for循环里面，而图遍历是在for循环外面，两者有何区别</p></blockquote><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221014111359709.png" alt="image-20221014111359709"></p><h2 id="环检测"><a href="#环检测" class="headerlink" title="环检测"></a>环检测</h2><p><a href="https://leetcode.cn/problems/course-schedule/">课程表</a></p><p>首先，需要将题目的输入转化成图。</p><ul><li><p>图有两种存储方式，邻接矩阵和邻接表，比较常用的邻接表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; []graph;</span><br></pre></td></tr></table></figure></li><li><p>图遍历算法，遍历过程中记录路径，看路径是否存在环</p></li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>关键：输出拓扑序列</p><blockquote><p>为什么后序遍历的反转就是拓扑排序</p><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221019112437232.png" alt="image-20221019112437232"></p></blockquote><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><blockquote><p><strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong></p></blockquote><p>框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def <span class="title function_">backtrack</span><span class="params">(路径, 选择列表)</span>:</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">        做选择  <span class="comment">// 其实，就是前序遍历的位置：在进入某一个节点之前执行</span></span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择 <span class="comment">// 后序遍历的位置，在离开某个节点之后执行</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 Java 的语言特性，因为 Java 函数参数传的是对象引用，所以向 <code>res</code> 中添加 <code>path</code> 时需要拷贝一个新的列表，否则最终 <code>res</code> 中的列表都是空的</p></blockquote><p>在递归之前做选择，在递归之后撤销选择</p><p>站在回溯树的一个节点上，你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>例1：「<a href="https://leetcode.cn/problems/permutations/">全排列</a>」（无重复数字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] used=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums,path,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 路径：结果保存在path中</span></span><br><span class="line">    <span class="comment">// 选择列表 used数组中为false的</span></span><br><span class="line">    <span class="comment">// 结束条件 used全部为true</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> nums[],LinkedList&lt;Integer&gt; path,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;  <span class="comment">//结束条件</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;  <span class="comment">//遍历选择</span></span><br><span class="line">                <span class="comment">//做选择</span></span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                backtrack(nums,path,used);</span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.removeLast();</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：力扣第 51 题「 <a href="https://leetcode.cn/problems/n-queens/">N 皇后</a>」</p><p>困难的地方在于如何做选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">char</span> board[][]=<span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           Arrays.fill(board[i],<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        backtrack(board,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==board.length)&#123; <span class="comment">//结束条件</span></span><br><span class="line">            print(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;board.length;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(board,row,col))&#123;  <span class="comment">//满足条件，做选择</span></span><br><span class="line">                board[row][col]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backtrack(board,row+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//撤销选择</span></span><br><span class="line">                board[row][col]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可以在board[row][col] 放置皇后</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=board.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 判断左斜线上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Math.min(row,col);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row-i][col-i]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断右斜线上是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Math.min(row,n-<span class="number">1</span>-col);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row-i][col+i]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; temp=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> <span class="title class_">String</span>(board[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用回溯算法解决排列-组合-子集问题"><a href="#使用回溯算法解决排列-组合-子集问题" class="headerlink" title="使用回溯算法解决排列-组合-子集问题"></a>使用回溯算法解决排列-组合-子集问题</h2><p>组合树</p><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221013110112647.png" alt="image-20221013110112647"></p><p>特性：</p><p>将根节点作为第0层，该节点的值为该节点到根节点之间树枝上的元素，第n层的所有节点就是大小为n的所有子集。</p><p><a href="https://leetcode.cn/problems/subsets/">子集</a>  不含重复元素</p><p><a href="https://leetcode.cn/problems/combinations/">组合</a></p><p><a href="https://leetcode.cn/problems/subsets-ii/">子集 II</a>  含重复元素</p><blockquote><p>跟子集那题的不同之处，在于给出的数组中是含有重复元素的</p><p>我一开始想的是，结果集用Set来装不就可以去除重复的吗？ 但不对，在回溯的时候，我们需要将上一次加入的节点移除，那set这个数据结构做不到，它只能将指定的元素移除。</p><p>正确做法：剪枝</p><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221014090918402.png" alt="image-20221014090918402"></p><p>先将元素排序，如果nums[i]==nums[i-1]跳过</p></blockquote><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221013110126245.png" alt="image-20221013110126245"></p><p><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和 II</a></p><p><a href="https://leetcode.cn/problems/permutations-ii/">全排列 II</a>  含重复元素</p><p>如何将去掉重复的排列  –&gt;如何剪枝</p><p>【保证相同元素在结果中的相对位置保持不变】</p><p> <a href="https://leetcode.cn/problems/combination-sum/">组合总和</a> 元素无重，可重复选</p><p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221014105002963.png" alt="image-20221014105002963"></p><h2 id="集合划分"><a href="#集合划分" class="headerlink" title="集合划分"></a>集合划分</h2><p>把装有n个数字的数组nums分成k个和相同的集合</p><p><strong>从数字的角度</strong></p><p>每个数字都要放入k个桶中的一个  【有些可以放，有些不可以】</p><p><strong>从桶的角度</strong></p><p>对于每个桶，遍历n个数字，选择是否将当前遍历到的数字装到这个桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> bucket[];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % k !=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> target=sum/k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">boolean</span> vis[]=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> backtrack(nums,<span class="number">0</span>,target,vis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 思路1：nums数组的每一个数字放到bucket   超时</span></span><br><span class="line">    <span class="comment">// 思路2: 从桶的视角，对于每一个桶，遍历nums数组中的每个数字，看是否放入这个桶</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> index,<span class="type">int</span> target,<span class="type">boolean</span> vis[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==bucket.length)&#123; <span class="comment">//终止条件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列举所有选择，每个球只能放入一个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 减枝</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bucket[index]+nums[i]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            bucket[index]+=nums[i];</span><br><span class="line">            vis[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(bucket[index]==target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(backtrack(nums,index+<span class="number">1</span>,target,vis))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//未装满，继续装</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            bucket[index] = bucket[index]-nums[i];</span><br><span class="line">            vis[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有任何一个数字可以放入这个桶</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都有超时，还没优化</p><h1 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h1><p>BFS问题的本质就是从一幅图的起点到终点的最短距离</p><p>框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/open-the-lock/">打开转盘锁</a></p><h2 id="双向BFS优化"><a href="#双向BFS优化" class="headerlink" title="双向BFS优化"></a>双向BFS优化</h2><p>传统的BFS：从起点开始到四周扩散，遇到终点时停止。</p><p>双向BFS:从起点和终点同时扩散，当两边有交集时停止。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表题型</title>
      <link href="/2022/10/25/%E9%93%BE%E8%A1%A8%E9%A2%98%E5%9E%8B%E6%B1%87%E6%80%BB/"/>
      <url>/2022/10/25/%E9%93%BE%E8%A1%A8%E9%A2%98%E5%9E%8B%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="链表题型汇总"><a href="#链表题型汇总" class="headerlink" title="链表题型汇总"></a>链表题型汇总</h1><ul><li>判断链表是否存在环，并找出这个环节点</li></ul><blockquote><p>通过快慢指针，如果快慢指针相遇，说明链表是存在环的。</p></blockquote><p><a href="https://leetcode.cn/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></p><blockquote><p>方法1：遍历单链表，记录路径  </p><p>方法2：不需要额外空间，通过以下方法</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210241147881.png" alt="image-20221017112740803"></p><p>fast比slow多走了k步，k是环长度的整数倍。</p><p>假设相遇点距离环的入口起点为m;则head距离环入口起点k-m【相遇点再走k-m步也能到达环的入口起点】</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第 89 场双周赛复盘</title>
      <link href="/2022/10/18/%E7%AC%AC%2089%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
      <url>/2022/10/18/%E7%AC%AC%2089%20%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第-89-场双周赛复盘"><a href="#第-89-场双周赛复盘" class="headerlink" title="第 89 场双周赛复盘"></a>第 89 场双周赛复盘</h1><blockquote><p>最后一题尚未解决</p></blockquote><h2 id="二的幂数组中查询范围内的乘积"><a href="#二的幂数组中查询范围内的乘积" class="headerlink" title="二的幂数组中查询范围内的乘积"></a><a href="https://leetcode.cn/problems/range-product-queries-of-powers/">二的幂数组中查询范围内的乘积</a></h2><p>关键在于：求出power数组，power数组存放一个数的二进制分解结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ind=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= MAXP; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        power[ind++]=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="最小化数组中的最大值"><a href="#最小化数组中的最大值" class="headerlink" title="最小化数组中的最大值"></a><a href="https://leetcode.cn/problems/minimize-maximum-of-array/">最小化数组中的最大值</a></h2><p>最小化最大值   —&gt; 二分答案</p><p>二分答案的模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(mid))</span><br><span class="line">        ans=mid,r=mid-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimizeArrayValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">1000000000</span>;</span><br><span class="line">        <span class="type">int</span> ans=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(nums,mid))&#123;</span><br><span class="line">                ans=mid;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> limit)</span>&#123;</span><br><span class="line">        <span class="type">long</span> copy[]=<span class="keyword">new</span> <span class="title class_">long</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            copy[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int[] copy=Arrays.copyOf(nums,nums.length);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(copy[i]&gt;limit)&#123;</span><br><span class="line">                copy[i-<span class="number">1</span>]=copy[i-<span class="number">1</span>]-limit+copy[i];</span><br><span class="line">                copy[i]=limit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(copy[<span class="number">0</span>]&lt;=limit)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的题</p><p><a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">2187. 完成旅途的最少时间</a></p><h2 id="2440-创建价值相同的连通块"><a href="#2440-创建价值相同的连通块" class="headerlink" title="2440. 创建价值相同的连通块"></a><a href="https://leetcode.cn/problems/create-components-with-same-value/">2440. 创建价值相同的连通块</a></h2><blockquote><p>有点难，先放一下</p></blockquote><p>关键：学会统计子树的大小/统计子树的点权和</p><p><strong>思路：</strong></p><ul><li>首先一个明显的性质，s=sum(nums)，如果要把树分成权值和相同的x个连通块，那么s能整除x。</li><li>那么考虑枚举每个连通块的权值和i，如果能整除，那么尝试分成s//i块，删除的边数就是s//i - 1 【因为题目给出的是一棵树】。</li><li>问题就是如何尝试分成s//i块，且每块权值和是i。</li><li>那么按照灵神给出的<code>计算子树权值和</code>模板,我们试图让每个子树的价值是i。</li><li>显然，如果子树和超过i，不合法，可以提前返回，我们用-1标志它不合法。</li><li>如果子树和正好是i，那么剪掉这颗子树即可，返回0。</li><li>最后检查根节点所在的连通块是0即可。</li></ul><p>如果一颗子树的价值等于target，那么可以将其作为一个连通块，和其父节点断开，换句话说，它对其祖先节点的价值贡献是0。</p><p>DFS这棵树，统计子树的价值：</p><p>如果价值超过target，那么当前删边方案不合法，返回 −1。<br>如果价值等于target，找到了一个连通块，和其父节点断开，返回 0。<br>如果价值小于target，尚未找到一个完整的连通块，返回价值。<br>如果 DFS 完了没有返回−1，则当前删边方案合法。如果从大到小枚举连通块的个数，则此时可以直接返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sum</span> <span class="operator">=</span> nums[x]; <span class="comment">// 价值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y : g[x])</span><br><span class="line">        <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> dfs(y, x);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            sum += res;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sum &lt; target ? sum : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode周赛复盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/10/15/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/10/15/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ul><li><p>英文字符与空格或操作将其转换为小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;D&#x27;</span> | <span class="string">&#x27; &#x27;</span>)   <span class="comment">// d</span></span><br><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;d&#x27;</span> | <span class="string">&#x27; &#x27;</span>)   <span class="comment">// d</span></span><br></pre></td></tr></table></figure></li><li><p>英文字符与下划线与操作将其转化为大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;d&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>)  <span class="comment">// D</span></span><br><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;D&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>)  <span class="comment">// D</span></span><br></pre></td></tr></table></figure></li><li><p>英文字符与空格异或操作进行大小写互换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>)  <span class="comment">// d</span></span><br><span class="line">(<span class="type">char</span>) (<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>)  <span class="comment">// D</span></span><br></pre></td></tr></table></figure></li><li><p>判断两个数是否异号（通过商或者乘积的方式，容易会导致结果溢出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=-<span class="number">2</span>; <span class="type">int</span> y=<span class="number">1</span>;</span><br><span class="line">System.out.println((x^y)&lt;<span class="number">0</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="n-amp-（n-1）"><a href="#n-amp-（n-1）" class="headerlink" title="n &amp;（n-1）"></a>n &amp;（n-1）</h2><p>作用就是将最后一位1变成0</p><p><a href="https://leetcode.cn/problems/number-of-1-bits/">位 1 的个数</a></p><p><a href="https://leetcode.cn/problems/power-of-two/">2 的幂</a></p><h2 id="a-a-0-a-0-a"><a href="#a-a-0-a-0-a" class="headerlink" title="a ^ a =0  a ^ 0= a"></a>a ^ a =0  a ^ 0= a</h2><p>异或运算满足交换律和结合律</p><p><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></p><p><a href="https://leetcode.cn/problems/missing-number/">丢失的数字</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序和快速排序实质</title>
      <link href="/2022/10/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/10/12/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><strong>归并排序实质是二叉树的后序遍历</strong>。</p><p>思想：先将左半边数组排好序，再将右半边数组排好序，将两个排好序的数组合并。</p><p>代码实现：</p><ul><li>提前将数组new出来，避免在递归中频繁的分配和释放内存，影响性能</li></ul><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121051844.png" alt="image-20221007105133279" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line">    <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组a[start...end]排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(end-start&lt;=<span class="number">0</span>)&#123;  <span class="comment">// 小于一个元素不必排了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对前半部分排序</span></span><br><span class="line">        sort(a, start, mid);</span><br><span class="line">        <span class="comment">// 对后半部分排序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 合并  --&gt; 后序遍历位置</span></span><br><span class="line">        merge(a, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将a[start...mid] 和 a[mid+1...end]两个数组合并</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> start,<span class="type">int</span> mid,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            temp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low=start;</span><br><span class="line">        <span class="type">int</span> high=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p=start;p&lt;=end;p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low==mid+<span class="number">1</span>)&#123;  <span class="comment">//左边数组全部排完</span></span><br><span class="line">                a[p]=temp[high++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(high==end+<span class="number">1</span>)&#123;  <span class="comment">//右边数组全部排完</span></span><br><span class="line">                a[p]=temp[low++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[low]&lt;=temp[high])&#123;</span><br><span class="line">                a[p]=temp[low++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[low]&gt;temp[high])&#123;</span><br><span class="line">                a[p]=temp[high++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何计算这个算法的复杂度？</strong></p><p>递归算法的复杂度计算：子问题个数 x 解决一个子问题的复杂度</p><p>应用</p><p>第 315 题「 <a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a>」</p><img src="C:/Users/shatianhui/AppData/Roaming/Typora/typora-user-images/image-20221007112047503.png" alt="image-20221007112047503" style="zoom:50%;" /><p>**对 <code>nums[lo..hi]</code> 合并的过程中，每当执行 <code>nums[p] = temp[i]</code> 时，就可以确定 <code>temp[i]</code> 这个元素后面比它小的元素个数为 <code>j - mid - 1</code>**。</p><p>这题还是挺难的</p><p>第 493 题「 <a href="https://leetcode.cn/problems/reverse-pairs/">翻转对</a>」</p><p>当 <code>nums[lo..mid]</code> 和 <code>nums[mid+1..hi]</code> 两个子数组完成排序后，对于 <code>nums[lo..mid]</code> 中的每个元素 <code>nums[i]</code>，去 <code>nums[mid+1..hi]</code> 中寻找符合条件的 <code>nums[j]</code> 就行了。</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序实质是<code>二叉树的先序遍历</code></p><p>思想：先将一个元素排好序，再将剩下的元素排好序</p><p>为解决构建的二叉搜索树不平衡的问题</p><ul><li>在排序之前使用洗牌算法将整个数组打乱</li><li>在partition函数中随机选择一个数作为分界点</li></ul><h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p>分析洗牌算法正不正确：一个长度为n的数组，产生的结果必须是n!种可能。【每种可能结果出现的概率必须相等】</p><p>如果不用数学严格证明概率相等，可以用<code>蒙特卡罗方法</code>地估计出概率是否相等，结果是否足够随机。</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121051086.png" alt="image-20221010094931348"></p><p>记得高中有道数学题：往一个正方形里面随机打点，这个正方形里紧贴着一个圆，告诉你打点的总数和落在圆里的点的数量，让你计算圆周率</p><p>这其实就是利用了蒙特卡罗方法：当打的点足够多的时候，点的数量就可以近似代表图形的面积。通过面积公式，由正方形和圆的面积比值是可以很容易推出圆周率的</p><p>类似的，我们可以对同一个数组进行一百万次洗牌，统计各种结果出现的次数，把频率作为概率，可以很容易看出洗牌算法是否正确。</p><p><strong>快速排序的代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> nums[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对nums[lo..hi]进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(lo&gt;=hi)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p= partition(nums,lo,hi);</span><br><span class="line">        sort(nums,lo,p-<span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot=nums[lo];</span><br><span class="line">        <span class="comment">// 保证[lo,i) &lt;=pivot  (j,hi]&gt;pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>lo+<span class="number">1</span>; <span class="type">int</span> j= hi;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;hi &amp;&amp; nums[i]&lt;=pivot)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="comment">// 跳出循环， nums[i]&gt; pivot</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;lo &amp;&amp; nums[j]&gt;pivot)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="comment">// 跳出循环   nums[j]&lt;=pivot</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123; <span class="comment">// 已经符合要求，跳出while循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用洗牌算法将一个数组打乱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span> nums[])</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> ind=i+rand.nextInt(n-i); <span class="comment">//生成[i,n-1]索引</span></span><br><span class="line">            swap(nums, i, ind);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变体-快速选择算法"><a href="#变体-快速选择算法" class="headerlink" title="变体-快速选择算法"></a>变体-快速选择算法</h2><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><p>方法1：二叉堆（优先队列）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue= <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((o1,o2)-&gt; o2-o1);<span class="comment">//最大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        queue.add(nums[i]); <span class="comment">// 时间复杂度O(logk)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogk）</p><p>方法2:快速选择算法</p><p>求排名第k的元素</p><p><code>partition</code> 函数会将 <code>nums[p]</code> 排到正确的位置，使得 <code>nums[lo..p-1] &lt; nums[p] &lt; nums[p+1..hi]</code></p><p>此时nums[p]的排名就知道了为p， 将p和k比较，如果p&gt;k,说明结果在<code>nums[lo..p-1]</code>;如果p&lt;k,说明结果在<code>nums[p+1..hi]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 求第k个最大，也就是求数组升序后第n-k个元素</span></span><br><span class="line">        <span class="type">int</span> n= nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> n-k;</span><br><span class="line">        <span class="type">int</span> lo=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> hi=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            <span class="type">int</span> p=partition(nums,lo,hi);</span><br><span class="line">            <span class="keyword">if</span>(p==rank)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[p];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&lt;rank)&#123;</span><br><span class="line">                lo=p+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&gt;rank)&#123;</span><br><span class="line">                hi=p-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot=nums[lo];</span><br><span class="line">        <span class="type">int</span> i=lo+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j=hi;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;hi &amp;&amp; nums[i]&lt;=pivot)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;lo &amp;&amp; nums[j]&gt;pivot)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,j,lo);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数组随机打乱，避免极端情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span> nums[])</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> ind=i+rand.nextInt(n-i);</span><br><span class="line">            swap(nums,i,ind);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速选择算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>314场周赛复盘</title>
      <link href="/2022/10/12/314%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/"/>
      <url>/2022/10/12/314%E5%9C%BA%E5%91%A8%E8%B5%9B%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="314场周赛复盘"><a href="#314场周赛复盘" class="headerlink" title="314场周赛复盘"></a>314场周赛复盘</h1><h2 id="第四道"><a href="#第四道" class="headerlink" title="第四道"></a>第四道</h2><p><a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">6203. 矩阵中和能被 K 整除的路径</a></p><p>dfs 必定超时</p><p>动态规划</p><blockquote><p>确定状态（原问题和子问题变化的部分）：i，j, 从（0，0）到（i，j）路径和与k的余数也是一直变化的</p><p>确定dp数组的含义：<code>dp[i][j][x]</code>:从（0，0）到（i，j）路径和mod k ==x的数量</p><p>确定选择：向右，向下</p><p>我们要求：<code>dp[m-1][n-1][0]</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> V=<span class="number">7</span>+<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> m=grid.length;</span><br><span class="line">        <span class="type">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> dp[][][]=<span class="keyword">new</span> <span class="title class_">int</span>[m][n][k];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 处理第0行</span></span><br><span class="line">        <span class="type">int</span> sum=grid[<span class="number">0</span>][<span class="number">0</span>]%k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j][(sum+grid[<span class="number">0</span>][j])%k]=dp[<span class="number">0</span>][j-<span class="number">1</span>][sum] %V;</span><br><span class="line">            sum=(sum+grid[<span class="number">0</span>][j])%k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理第0列</span></span><br><span class="line">        sum=grid[<span class="number">0</span>][<span class="number">0</span>]%k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][(sum+grid[i][<span class="number">0</span>])%k]=dp[i-<span class="number">1</span>][<span class="number">0</span>][sum] %V;</span><br><span class="line">            sum=(sum+grid[i][<span class="number">0</span>])%k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;k;x++)&#123;</span><br><span class="line">                    dp[i][j][(x+grid[i][j])%k]=(dp[i-<span class="number">1</span>][j][x]+dp[i][j-<span class="number">1</span>][x])%V;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的题目</p><p>力扣第 64 题「 <a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a>」</p><p>求解到达最右下方经过的路径和最小。</p><blockquote><p><code>dp[i][j]</code>:从（0，0）到（i，j）路径和最小的值</p><p>状态转移方程 <code>dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</code></p></blockquote><p><a href="https://leetcode.cn/problems/dungeon-game/">174. 地下城游戏</a></p><blockquote><p><code>dp[i][j]</code>:表示从(0,0)到（i，j）需要的最低初始健康点数</p></blockquote><p>难点：「到达 <code>A</code> 的最小生命值」不能由「到达 <code>B</code> 的最小生命值」和「到达 <code>C</code> 的最小生命值」推导出来</p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121104720.png" alt="image-20221011091815457" style="zoom:50%;" /><p>因为：到达B，到达C的生命值是不知道的</p><p>所以，上面的dp定义不对</p><p>**==反向思考==**：  这题非常好</p><blockquote><p><code>dp[i][j]</code>:从(m-1,n-1)到（i，j）需要的最低初始健康点数</p><p>边界：</p><p><code>dp[m-1][i]=dungeon[m-1][i]&gt;=dp[m-1][i+1] ? 1:dp[m-1][i+1]-dungeon[m-1][i];</code></p><p>状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp=Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]);</span><br><span class="line">dp[i][j]= dungeon[i][j]&gt;temp? <span class="number">1</span>: temp-dungeon[i][j];</span><br></pre></td></tr></table></figure></blockquote><h2 id="第三道"><a href="#第三道" class="headerlink" title="第三道"></a>第三道</h2><p><a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/">2434. 使用机器人打印字典序最小的字符串</a></p><p>关键在于：什么时候出栈</p><p>当该栈顶元素比后序元素都小于等于时出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">robotWithString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span>[] nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] str=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:str)&#123;</span><br><span class="line">            nums[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:str)&#123;</span><br><span class="line">            </span><br><span class="line">            stack.push(c);</span><br><span class="line">            nums[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 判断是否需要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; isSmall(nums,c))&#123;  <span class="comment">// 当前栈顶元素比后序元素都要小于等于</span></span><br><span class="line">                sb.append(stack.pop());</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    c=stack.peek();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSmall</span><span class="params">(<span class="type">int</span> nums[],<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span>c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的题</p><blockquote><p>给定长度为 N 的字符串 S，要构造一个长度为 N 的字符串 T。起初，T 是一个空串，随后反复执行下列两个操作中的任意一个，最终目标是构造字典序尽可能小的字符串 T。</p><p>操作一：从 S 的头部取一个字符，加到 T 的尾部。</p><p>操作二：从 S 的尾部取一个字符，加到 T 的尾部。</p><p>例如：输入 N=6，S=ACDBCB；构造的 T=ABCBCD</p></blockquote><p>这题简单多了：双指针就可以</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode周赛复盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redisson分布式锁原理</title>
      <link href="/2022/10/10/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/10/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redisson-分布式锁原理"><a href="#Redisson-分布式锁原理" class="headerlink" title="Redisson 分布式锁原理"></a>Redisson 分布式锁原理</h1><h2 id="Redisson如何解决重入问题"><a href="#Redisson如何解决重入问题" class="headerlink" title="Redisson如何解决重入问题"></a>Redisson如何解决重入问题</h2><p>可重入锁：同一线程可以获取同一把锁</p><p>实现：在获取锁的时候，如果存在，判断锁标识是不是同一个线程，如果是，也可以获取锁，并使用计数器记录重入的次数</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210081650272.png" alt="1653548087334"></p><h3 id="lua-脚本获取锁trylock"><a href="#lua-脚本获取锁trylock" class="headerlink" title="lua 脚本获取锁trylock"></a>lua 脚本获取锁trylock</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1]  代表锁的key</span></span><br><span class="line"><span class="comment">-- ARGV[1]  锁失效时间</span></span><br><span class="line"><span class="comment">-- ARGV[2]  id+&quot;:&quot;+threadID 线程唯一标识</span></span><br><span class="line"><span class="comment">-- 判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁不存在</span></span><br><span class="line">    <span class="comment">-- 在redis中添加锁  源码中使用的是hincrby</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    <span class="comment">-- 设置锁的过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="comment">-- 说明锁已经存在</span></span><br><span class="line"><span class="comment">-- 通过锁的key和线程唯一表述判断锁是不是自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="comment">-- 锁是自己的</span></span><br><span class="line">    <span class="comment">-- 计数器加一</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">    <span class="comment">--重新设置过期时间，保证有充足时间执行业务</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"># 锁存在，但不是自己的（获取锁失败），返回锁剩余有效时间（单位毫秒）</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="lua-脚本释放锁-unlock"><a href="#lua-脚本释放锁-unlock" class="headerlink" title="lua 脚本释放锁 unlock"></a>lua 脚本释放锁 unlock</h3><p>释放锁也涉及如何解决锁的重试问题。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS[1] 锁的key</span></span><br><span class="line"><span class="comment">-- KEYS[2] 跟发布消息有关，具体是什么不知道</span></span><br><span class="line"><span class="comment">-- ARGV[1] 跟发布消息有关，具体是什么不知道</span></span><br><span class="line"><span class="comment">-- ARGV[2] 锁自动释放时间 </span></span><br><span class="line"><span class="comment">-- ARGV[3] 线程唯一标识</span></span><br><span class="line"><span class="comment">--判断锁是不是自己</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">    <span class="comment">-- 不是自己的锁，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 锁标识是自己的锁</span></span><br><span class="line"><span class="comment">-- 重入次数减一</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);</span><br><span class="line"><span class="comment">-- 重入次数是否等于0</span></span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 还有锁没有释放，重置有效期，然后返回</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]); <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 重入次数为0 释放锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line">    <span class="comment">-- 发布消息，告诉其他线程锁已经释放</span></span><br><span class="line">    redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure><h2 id="Redisson如何解决锁重试问题"><a href="#Redisson如何解决锁重试问题" class="headerlink" title="Redisson如何解决锁重试问题"></a>Redisson如何解决锁重试问题</h2><p>首先，学习tryLock()方法的参数</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121048153.png" alt="image-20221005195501228"></p><p>redisson中tryLock()参数解释</p><ul><li>第一个参数 waitTime 指定了这个锁，那么锁就是可重试锁，超过waitTime，才返回获取锁失败</li><li>第二个参数  leaseTime 锁超时释放时间  不指定  30s</li><li>第三个参数 单位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 两种结果：获取锁成功，返回null,获取锁失败，返回剩余有效时间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取锁成功，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="comment">// 等待时间减获取锁花费时间，看是否有剩余</span></span><br><span class="line">        time -= System.currentTimeMillis() - current;</span><br><span class="line">        <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有剩余，则返回获取锁失败</span></span><br><span class="line">            <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 有剩余，但是没有立即重试（立即重试，大概率还是失败，增加CPU的负担）</span></span><br><span class="line">            current = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 订阅释放锁时发布的通知，这个结果是不确定的，所以是用Future接收</span></span><br><span class="line">            RFuture&lt;RedissonLockEntry&gt; subscribeFuture = <span class="built_in">this</span>.subscribe(threadId);</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="comment">// 等到剩余等待时间用完都还没有收到通知</span></span><br><span class="line">                <span class="comment">// 取消订阅</span></span><br><span class="line">                <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">                    subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 返回获取锁失败</span></span><br><span class="line">                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//收到了释放锁通知</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 计算剩余等待时间</span></span><br><span class="line">                    time -= System.currentTimeMillis() - current;</span><br><span class="line">                    <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">var20</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var20;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 有剩余时间，重试</span></span><br><span class="line">                        <span class="type">boolean</span> var16;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            ttl = <span class="built_in">this</span>.tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">                            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                                var16 = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="comment">// 重试，还是失败</span></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                            <span class="keyword">if</span> (time &lt;= <span class="number">0L</span>) &#123; <span class="comment">//剩余等待时间没有了</span></span><br><span class="line">                                <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                                var16 = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span> var16;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            currentTime = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (ttl &gt;= <span class="number">0L</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">                                <span class="comment">// 锁剩余有效时间小于剩余等待时间，在锁剩余有效时间内订阅锁释放信号量</span></span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">                        &#125; <span class="keyword">while</span>(time &gt; <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">this</span>.acquireFailed(waitTime, unit, threadId);</span><br><span class="line">                        var16 = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> var16;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.unsubscribe(subscribeFuture, threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：使用消息订阅和信号量机制（等你释放锁的时候，发送消息告诉我一声，我再去尝试），而不是无休止的重试（增加CPU负担）</p><h2 id="Redisson如何解决超时释放"><a href="#Redisson如何解决超时释放" class="headerlink" title="Redisson如何解决超时释放"></a>Redisson如何解决超时释放</h2><p>【这个其实，还是有点疑惑】</p><p>如果一个线程因为阻塞导致ttl到期释放了锁，然后其他线程获取到了锁</p><p>所以，Redisson是如何保证获取锁是因为别的线程执行完业务释放锁，而不是其他异常时获取的锁  –&gt; 不理解</p><blockquote><p>我觉得看门狗机制解决的问题</p><p>如果锁的超时释放时间设置为-1，没有设置看门狗机制，该线程阻塞了，一直不释放锁，那么其他线程就获取不到这个锁。有了看门狗机制，10s内没有续约超时释放时间，那么锁就自动释放了，其他线程就可以获得锁了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未指定超时释放时间，使用默认30s</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        </span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">//一个锁对应一个entry</span></span><br><span class="line">    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonLock</span>.ExpirationEntry();</span><br><span class="line">    <span class="comment">// map的key对应锁的key,value对应entry</span></span><br><span class="line">    <span class="comment">// 第一次，oldEntry=null</span></span><br><span class="line">    <span class="comment">// 不管重入几次，oldEntry返回的都是相同的entry</span></span><br><span class="line">    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重入，线程id都是一样的</span></span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个获取锁</span></span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 延时任务，第一个参数：任务，第二个参数：多少时间后执行这个任务，第三个任务：单位  未指定锁释放时间，那么10后执行这个任务</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                    <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                    <span class="comment">//递归，一直执行这个延时任务，不断重置，使其锁的有效期永不过期</span></span><br><span class="line">                                    RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>internalLockLeaseTime</code></p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121048396.png" alt="image-20221008202426346"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置当前锁的有效期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.evalWriteAsync(<span class="built_in">this</span>.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;</span>, Collections.singletonList(<span class="built_in">this</span>.getName()), <span class="built_in">this</span>.internalLockLeaseTime, <span class="built_in">this</span>.getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，什么时候取消这个延时任务 【锁释放的时候取消】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = <span class="built_in">this</span>.unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.trySuccess((Object)<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelExpirationRenewal</span><span class="params">(Long threadId)</span> &#123; <span class="comment">//取消延时任务</span></span><br><span class="line">    RedissonLock.<span class="type">ExpirationEntry</span> <span class="variable">task</span> <span class="operator">=</span> (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.removeThreadId(threadId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span> || task.hasNoThreads()) &#123;</span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> task.getTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EXPIRATION_RENEWAL_MAP.remove(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redisson如何解决主从一致性问题"><a href="#Redisson如何解决主从一致性问题" class="headerlink" title="Redisson如何解决主从一致性问题"></a>Redisson如何解决主从一致性问题</h2><p>主从一致性产生原因：单节点redis,如果该redis出现问题，所有依赖于redis的都会出现问题（包括分布式锁），这时候需要使用redis集群或主从，提高redis的可用性</p><p>主节点负责redis写操作，从节点负责redis读操作，主从节点需要数据同步。</p><blockquote><p>如何使用redis搭建集群还不会</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redisson分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法(一）</title>
      <link href="/2022/10/05/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
      <url>/2022/10/05/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056927.png" alt="image-20220930111729075"></p><p>父结点索引 i/2</p><p>左孩子结点索引  2*i  右孩子结点索引2<code>*</code>i</p><p>最大堆：每个结点都大于等于它的两个左右子结点</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>功能：插入和删除元素，元素会自动排序。底层二叉树操作</p><p>最大优先级队列代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123; <span class="comment">// Key是任何一种可比较大小的数据类型</span></span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">        <span class="comment">//先插入到堆底，然后上浮</span></span><br><span class="line">        size++;</span><br><span class="line">        pq[size]=e;</span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        Key max=pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把最大元素放到最后，并删除</span></span><br><span class="line">        swap(<span class="number">1</span>,size);</span><br><span class="line">        pq[size]=<span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 调整堆</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">1</span> &amp;&amp; less(parent(x),x))&#123; <span class="comment">//当前结点比父结点大</span></span><br><span class="line">            swap(parent(x),x);</span><br><span class="line">            x=parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="comment">// 下沉某个结点，需要该结点和其左右子节点比较，如果该结点不是最大的，就和较大的子节点交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 直到到堆底</span></span><br><span class="line">        <span class="keyword">while</span>(left(x) &lt;=size)&#123;</span><br><span class="line">            <span class="type">int</span> max=left(x); <span class="comment">//记录左右子节点较大的那个</span></span><br><span class="line">            <span class="keyword">if</span>(right(x)&gt;=size &amp;&amp; less(max,right(x)))&#123; <span class="comment">// 右结点一定要存在</span></span><br><span class="line">                max=right(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(less(max,x))&#123;  <span class="comment">//当前结点比左右结点大，不必下沉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(max,x);</span><br><span class="line">            x=max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 左孩子结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 右孩子结点索引 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java优先级队列实现类 PriorityQueue</p><h1 id="常数时间删除-查找数组中的任意元素"><a href="#常数时间删除-查找数组中的任意元素" class="headerlink" title="常数时间删除/查找数组中的任意元素"></a>常数时间删除/查找数组中的任意元素</h1><p>力扣第 380 题「 <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">常数时间插入、删除和获取随机元素</a>」</p><p>本题的难点在于两点：</p><p>**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)**。</p><p><strong>2、<code>getRandom</code> 方法返回的元素必须等概率返回随机元素</strong>，也就是说，如果集合里面有 <code>n</code> 个元素，每个元素被返回的概率必须是 <code>1/n</code></p><p>HashSet可以实现O(1)内插入，删除，但无法等概率返回随机元素</p><p>对于 <code>getRandom</code> 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：<strong>底层用数组实现，且数组必须是紧凑的</strong>。</p><p>用数组（List），插入删除操作O(1),就不能移动元素，使用HashMap记录元素与索引之间的关系。</p><p>最麻烦的应该是删除操作：更新map,最后一个元素直接删除，不是最后一个，和最后一个元素交换</p><p><strong>疑问：</strong>remove()方法有根据索引的，有根据值的，下面是根据索引还是值？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list); 【<span class="number">1</span>，<span class="number">2</span>】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是根据索引删除的，并没有根据值</p><p>力扣第 710 题「 <a href="https://leetcode.cn/problems/random-pick-with-blacklist/">黑名单中的随机数</a>」</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056245.png" alt="image-20221002114805505"></p><p>随机生成一个[0,sz), 如果生成的数在黑名单上，映射到sz后面的数</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>单调栈用于解决一类题，解决<code>下一类更大元素的问题</code></p><p>eg:一个数组 <code>nums = [2,1,2,4,3]</code>，返回结果 <code>[4,2,4,-1,-1]</code>。</p><p>暴力解法：O(n^2)  单调栈：O(n)</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210051056732.png" alt="image-20221005100932499"></p><p>算法模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的更大元素</span></span><br><span class="line">        res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题</p><p><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></p><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></p><p><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><p>第一类题： 数组原地去重  –&gt;   使用快慢指针</p><p>316 题「 <a href="https://leetcode.cn/problems/remove-duplicate-letters/">去除重复字母</a>」</p><p>该题：要求返回的结果字典序最小</p><p>利用栈</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先级队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分</title>
      <link href="/2022/09/30/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
      <url>/2022/09/30/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><p>没有重复元素的有序数组  普通二分查找</p><p>重复元素的有序数组  左侧边界的二分搜索，右侧边界的二分搜索</p><p><strong>左侧边界的二分搜索</strong></p><p>当target存在数组nums中时，返回的是第一个重复元素的索引</p><p>当target不存在数组nums中时</p><p>例：nums[]=[2,3,5,7]  target=4    返回的left=2</p><ul><li>left指向nums中大于target的最小元素索引</li><li>返回的是target应该插入的位置索引</li><li>返回nums数组中小于target的个数</li></ul><p><strong>右侧边界的二分搜索</strong></p><p>返回的是最后一个重复元素的索引</p><h1 id="二分搜索的应用"><a href="#二分搜索的应用" class="headerlink" title="二分搜索的应用"></a>二分搜索的应用</h1><p>什么问题可以应用二分搜索？</p><ul><li><input checked="" disabled="" type="checkbox"> 从题目中抽象出一个自变量 x，一个关于 x的函数 f(x)，以及一个目标值 target。</li></ul><p>同时，x, f(x), target 还要满足以下条件：</p><ol><li>f(x) 必须是在 x 上的单调函数（单调增单调减都可以）。</li><li>题目是让你计算满足约束条件 <code>f(x) == target</code> 时的 <code>x</code> 的值。</li></ol><p>例：<a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p><p>分析：自变量x是珂珂吃香蕉的速度，f(x)是吃完所有堆上所用时间。 x越大，吃的越快，所花时间f(x)就越小。吃香蕉的时间限制H就是target.</p><p>x的左右边界如何确定？ 最小速度=1 最大速度堆上最大的香蕉个数  使用左侧边界的二分搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=maxV(piles);</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(f(piles,mid)==h)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(piles,mid)&lt;h)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(piles,mid)&gt;h)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 速度为x时，吃完所有堆所需时间  递减可重复的有序序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> x)</span>&#123;   <span class="comment">// int类型不够</span></span><br><span class="line">        <span class="type">long</span> hours=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;piles.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]%x==<span class="number">0</span>)&#123;</span><br><span class="line">                hours+=piles[i]/x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hours=hours+<span class="number">1</span>+piles[i]/x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hours;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求堆中最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxV</span><span class="params">(<span class="type">int</span>[] piles)</span>&#123;</span><br><span class="line">        <span class="type">int</span> max=piles[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;piles.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(piles[i]&gt;max)&#123;</span><br><span class="line">                max=piles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p><p>自变量x为船载重，f(x)为所有包裹送达所需时间。</p><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>二分查找：在一个有序数据集上查找</p><p>二分答案：答案是某一个区间，在区间中二分</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分搜索 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 45讲（二）</title>
      <link href="/2022/09/29/MySql45%E8%AE%B2(2)/"/>
      <url>/2022/09/29/MySql45%E8%AE%B2(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><p>数据库原本c的值为1</p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202210121047079.png" alt="image-20220928113353148" style="zoom:50%;" /><p>不同隔离级别的结果</p><ul><li><p>隔离级别为<strong>读未提交</strong>（read uncommitted）:一个事务还没提交时，它的事务就能被别的事务所看见。</p><p>事务B未提交，但结果已经被事务A所看见。 V1=2 V2=2 V3=2</p></li><li><p>隔离级别为<strong>读提交</strong>（read committed）:一个事务提交之后，它的结果才能被其他事务所看见。</p><p>V1=1 V2=2 V3=2</p></li><li><p>隔离级别为<strong>可重复读</strong>（repeatable read）: 一个事务执行过程中看到的数据，总是和这个事务在启动时看到的一样。并且，未提交的变更对其他事务也是不可见的。</p><p>V1=1 V2=1 V3=2</p></li><li><p>隔离级别为<strong>串行化</strong>（serializable）:对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p>在事务B将1改成2时锁住，直到事务A执行完成,事务B才能继续执行。 V1=1 V2=1 V3=2</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 45讲（一）</title>
      <link href="/2022/09/27/MySql45%E8%AE%B2(1)/"/>
      <url>/2022/09/27/MySql45%E8%AE%B2(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="一条SQL查询语句的执行流程"><a href="#一条SQL查询语句的执行流程" class="headerlink" title="一条SQL查询语句的执行流程"></a>一条SQL查询语句的执行流程</h1><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615720.png" alt="image-20220927150319024"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。</li></ul><p>长连接 &amp; 短连接</p><p><strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</p><p><strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。但<strong>查询缓存的失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。MySQL 8.0版本无查询缓存功能。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>分析器先会做“词法分析”。MySQL需要识别出SQL语句的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>如下面这条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。</p><h1 id="一条SQL更新语句的执行流程"><a href="#一条SQL更新语句的执行流程" class="headerlink" title="一条SQL更新语句的执行流程"></a>一条SQL更新语句的执行流程</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>更新流程涉及两个重要的日志模块。redo log（重做日志）和 binlog（归档日志）</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>WAL（Write_Ahead Logging）技术: 先写日志，再写磁盘。</p><p>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p><p>InnoDB的redo log是固定大小的</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615895.png" alt="image-20220927154602131"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>两种日志的不同</p><ul><li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li><li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1”。</li><li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271615765.png" alt="image-20220927155212268"></p><p>redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>]]></content>
      
      
      <categories>
          
          <category> mysql高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL执行流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结构</title>
      <link href="/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><p><strong>二叉排序树</strong>，缺陷：在极端情况下，一个有序序列会退化成链表</p><p>所以，要使用<strong>平衡树</strong>来进行调节</p><p>为什么要保证树的平衡？ 因为树的查询效率取决于树的高度，让树尽可能的平衡，就是为了减少树的高度。</p><p>那<strong>B树</strong>的作用是什么？</p><p>B树又叫多路查找树，每个结点可以拥有多于两个孩子结点。m路B树最多就可以拥有m个孩子结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714106.png" alt="image-20220925162730234"></p><p>这是棵三路B树。为什么要设计成多路？就是为了进一步降低树的高度。路数越多，树就越低。那路数无限大，不就更好？</p><p>为什么文件系统的索引使用B树，而不使用红黑树或者是有序数组？</p><p>文件系统或者数据库的索引是存储在硬盘上的，如果数据量越大，就不能一次性的加载到内存。这时候，能够体现B树的多路存储作用，每次加载B树的一个结点，然后一步一步往下找。</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714091.png" alt="image-20220925163551755"></p><p>假设内存一次性只能加载两个树，这时候有序数组【25，25，30，40，43，45，50，59，65，77，85】是不能够一次性加载到内存的，所以，可以构建三路B树，每个结点至多有两个数。</p><p>那<strong>B+树</strong>有什么作用？</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714422.png" alt="image-20220925164941429"></p><p>这是一棵4路B+树，<strong>数据都在叶子结点，并且通过链表相连</strong>。</p><p>使用场景：比如select查询多条数据，B树可能需要做中序遍历，跨层访问，而B+树所有的数据都在叶子结点，同时拥有链表结构，只需要找到首尾，就可以把所有数据取出来。</p><p>mysql存储索引使用的是B+树。</p><p>B+树查询效率与树的高度有关，O(logn),而hash查询索引效率O(1),hash比B+树更快，为什么要用B+树，而不用hash?</p><p>1.只查询一个数据，确实是hash更快，单数据库经常查询的是多条数据，这时候B+树索引有序，又有链表相连，查询效率要比hash快很多。2.前面提到，数据库索引一般存储在磁盘，如果数据量大，一次可能无法装入内存，B+树可以分批加载，树的高度越低，可以提高查询效率。</p><h1 id="N叉树如何遍历"><a href="#N叉树如何遍历" class="headerlink" title="N叉树如何遍历"></a>N叉树如何遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></p><p>实际考察的就是N叉树的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedInteger</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> List&lt;NestedInteger&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NestedInteger</span><span class="params">(Integer value,List&lt;NestedInteger&gt; list)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value=value;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInteger</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getInteger</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title function_">getList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构其实就是一棵N叉树（好好感受）</p><p>解法：将所有叶子节点的值都放到一个res集合中，next()和hasNext()在res做迭代【这种方法，消耗内存大，需要获得所有的叶子节点值】</p><p>一般的迭代器求值应该是<code>惰性的</code>，也就是说，如果你要一个结果，我就算一个（或是一小部分）结果出来，而不是一次把所有结果都算出来</p><p>思路：调用 <code>hasNext</code>时，如果 <code>nestedList</code> 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉排序树 </tag>
            
            <tag> AVL </tag>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文系列</title>
      <link href="/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/"/>
      <url>/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ul><li>寻找回文串  –&gt; 双指针从两端向中间逼近</li><li>寻找一个字符串中最大回文串  –&gt; 寻找以s[left]和s[right]为中心的最长回文串  （中间向两端逼近）</li></ul><h1 id="判断回文单链表"><a href="#判断回文单链表" class="headerlink" title="判断回文单链表"></a>判断回文单链表</h1><p>思路1：将单链表的值放到数组中，然后通过数组来判断</p><p>思路2：反转单链表，判断两个链表是否完全相同</p><p>思路3：利用二叉树后序遍历思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ListNode left=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法1：将单链表反转成新的链表</span></span><br><span class="line">    <span class="comment">// 方法2：将单链表的值放到数组中，通过数组来判断</span></span><br><span class="line">    <span class="comment">// 方法3：利用二叉树后续遍历思路</span></span><br><span class="line">    left=head;</span><br><span class="line">    <span class="keyword">return</span> traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">traverse</span><span class="params">(ListNode right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> res= traverse(right.next);</span><br><span class="line">    res=res &amp;&amp; left.val==right.val;</span><br><span class="line">    left=left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路4：优化空间复杂度</p><ul><li>先找到链表的中点     使用快慢指针</li><li>反转后半部分链表  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法1：将单链表反转成新的链表</span></span><br><span class="line">    <span class="comment">// 方法2：将单链表的值放到数组中，通过数组来判断</span></span><br><span class="line">    <span class="comment">// 方法3：利用二叉树后续遍历思路</span></span><br><span class="line">    <span class="comment">// 方法4：寻找链表的中间结点，将链表的后半段翻转</span></span><br><span class="line">    ListNode slow=head; ListNode fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast!=<span class="literal">null</span>)&#123;  <span class="comment">//链表的结点个数是奇数</span></span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode right=reverse(slow);</span><br><span class="line">    ListNode left=head;</span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=left.next;</span><br><span class="line">        right=right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode slow)</span>&#123;</span><br><span class="line">    ListNode pre=<span class="literal">null</span>;</span><br><span class="line">    ListNode cur=slow;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode s=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>如何反转单链表？ <a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></p><ol><li><p>依靠栈</p></li><li><p>头插法，把原链表一个一个摘下，插入到新链表前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p=head.next;</span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode s=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">        s.next=pre;</span><br><span class="line">        pre=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p></li></ol><blockquote><p>递归的空间复杂度为O(N),而迭代的时间复杂度为O(1).</p></blockquote><h2 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h2><p><strong>==递归最重要的就是明确递归函数的含义==</strong></p><p>ListNode reverse(ListNode head) // 输入单链表头结点，将该头结点的整个链表反转，返回新的头结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251122515.png" alt="image-20220925112218962"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=ReverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方式，代码简洁优雅</p><h2 id="递归反转部分链表"><a href="#递归反转部分链表" class="headerlink" title="递归反转部分链表"></a>递归反转部分链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p><p>reverseBetween(ListNode head, int left, int right) //输入单链表头结点，将链表的第left结点到第right结点反转，返回新链表的头结点</p><p>首先，考虑如何反转前n个结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251152986.png" alt="image-20220925115211597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor=<span class="literal">null</span>; </span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head，<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        successor=head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=reverseN(head.next,n-<span class="number">1</span>);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：递归反转部分链表</p><p>left=1 就想当于反转前n个结点</p><p>left!=1 前进到反转的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a>k个一组反转链表</h2><p>递归解决</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209271024508.png" alt="image-20220927102415994"></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文串 </tag>
            
            <tag> 反转链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法</title>
      <link href="/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    HashMap&lt;<span class="type">int</span>,<span class="type">char</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>; <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;s.length)&#123;</span><br><span class="line">        <span class="comment">// 将该字符移入窗口</span></span><br><span class="line">        <span class="type">char</span> c=s[right];</span><br><span class="line">        right++; <span class="comment">//增大窗口</span></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">    <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：力扣第 76 题「 <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>」</p><p>思路：</p><ol><li>初始化左右指针left=right=0; 把[left,right) 左闭右开，作为窗口</li><li>不断增大right指针，直到窗口中的字符串符合要求（包含T中所有字符），停止增加right  ——&gt;寻找可行解</li><li>增大left指针，缩小窗口，直到窗口的字符串不再符合要求（不包含T中所有字符），停止增加left –&gt;这个可行解的最优解</li><li>重复第2第3步，直到right到达字符串的尽头  –&gt;最优解</li></ol><p>HashMap中记录窗口中的字符和需要凑齐的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录目标字符串，每个字符及对应需要的个数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need.get(t.charAt(i))==<span class="literal">null</span>)&#123;</span><br><span class="line">                need.put(t.charAt(i),<span class="number">1</span>);</span><br><span class="line">                window.put(t.charAt(i),<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                need.put(t.charAt(i),need.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;<span class="comment">//窗口需要满足的字符个数</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;<span class="type">int</span> end=s.length()+<span class="number">1</span>;  <span class="comment">// 记录最优字符的起始位置</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">char</span> c= s.charAt(right); <span class="comment">//加入窗口</span></span><br><span class="line">             right++;  <span class="comment">//扩大窗口</span></span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">                window.put(c,window.get(c)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(window.get(c).equals(need.get(c)))&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(valid==need.size())&#123; </span><br><span class="line">                <span class="comment">// 寻找可行解的最优解</span></span><br><span class="line">                <span class="keyword">if</span>(end-start&gt;right-left)&#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    end=right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d=s.charAt(left); <span class="comment">//移除窗口</span></span><br><span class="line">                left++;  <span class="comment">//缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(window.containsKey(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window.get(d).equals(need.get(d)))&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end-start==s.length()+<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 语言处理字符串还是有点麻烦的，一直使用charAt(i)  没有使用索引s[i]方便</p><p>同类型练习题</p><p>力扣第 567 题「 <a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>」   维护的滑动窗口定长</p><p>力扣第 438 题「 <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>」</p><p>力扣第 3 题「 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>」 </p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的字符串类</title>
      <link href="/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
      <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="String-不可变的字符串"><a href="#String-不可变的字符串" class="headerlink" title="String 不可变的字符串"></a>String 不可变的字符串</h2><p>String类部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="comment">// 可序列化</span></span><br><span class="line">    <span class="comment">// 可比较大小</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  <span class="comment">//数组元素不可修改（final）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>String类被定义成final,不能被扩展，也不需要被扩展（定义的方法很全）。</li><li>用char数组来存储，并定义成final，<strong>不可变</strong>。</li><li>对字符串操作，不改变原字符串，都是new String()。</li></ul><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209231515205.png" alt="image-20220421094420345" style="zoom:67%;" /><p>intern():如果字符串常量池中包含一个等于String对象的字符串（通过equals()）,则返回池中的字符串，否则，将String对象添加到池中，并返回该对象的引用。由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为真时，s.intern() == t.intern() 才为真。</p><h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>StringBuilder部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence&#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保存数据的char数组并未被定义成final</li><li>可变字符序列</li></ul><blockquote><ul><li>String是不可变字符序列，而StringBuffer，StringBuilder都是可变字符序列</li><li>String可以通过字面量方式赋值，StringBuffer/StringBuilder只能是通过构造器 new</li><li>StringBuffer线程安全，效率低（里面的方法都是synchronized,同步方法），而StringBuilder线程不安全的，效率高</li></ul></blockquote><p>三者底层都是使用char[]数组进行存储，那如何实现可变和不可变？</p><blockquote><p><code>String s=new String()</code> //new char[0],长度为0</p><p><code>String s=new String(&quot;abc&quot;)</code> //new char[3]{‘a’,’b’,’c’}</p><p><code>StringBuffer buffer=new StringBuffer()</code>// new char[capacity]   capacity=16</p><p><code>StringBuffer buffer1=new StringBuffer(&quot;abc&quot;)</code>// new char[s.length()+capacity]   capacity=16  capacity+s.length()作为初始容量，然后调用buffer.append()   （看一下如何进行扩容）</p><p>问题1：此时buffer1.length()  是3    //append()后count+buffer1.length()返回count的值，而不是数组的容量</p><p>问题2：char数组如何进行扩容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;   <span class="comment">//确保容量是够的</span></span><br><span class="line">  <span class="comment">// minimumCapacity是count+append的字符长度</span></span><br><span class="line"> <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;<span class="comment">//大于数组长度，不够了，需要扩容</span></span><br><span class="line">     value = Arrays.copyOf(value,</span><br><span class="line">                           newCapacity(minimumCapacity));<span class="comment">//默认下，扩充的容量是2倍的value+2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果append次数很多，频繁扩容，扩容要复制一份，影响效率，所以可以使用<code>StringBuffer(int capacity)</code>构造器,指定容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟 String做对比</span></span><br><span class="line">StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">buffer.setCharAt(<span class="number">1</span>,<span class="string">&#x27;m&#x27;</span>);<span class="comment">//void方法，没有返回值</span></span><br><span class="line">System.out.println(buffer);<span class="comment">//amc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串不可变性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
