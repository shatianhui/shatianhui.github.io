<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树结构</title>
      <link href="/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/2022/09/25/%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h1><p><strong>二叉排序树</strong>，缺陷：在极端情况下，一个有序序列会退化成链表</p><p>所以，要使用<strong>平衡树</strong>来进行调节</p><p>为什么要保证树的平衡？ 因为树的查询效率取决于树的高度，让树尽可能的平衡，就是为了减少树的高度。</p><p>那<strong>B树</strong>的作用是什么？</p><p>B树又叫多路查找树，每个结点可以拥有多于两个孩子结点。m路B树最多就可以拥有m个孩子结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714106.png" alt="image-20220925162730234"></p><p>这是棵三路B树。为什么要设计成多路？就是为了进一步降低树的高度。路数越多，树就越低。那路数无限大，不就更好？</p><p>为什么文件系统的索引使用B树，而不使用红黑树或者是有序数组？</p><p>文件系统或者数据库的索引是存储在硬盘上的，如果数据量越大，就不能一次性的加载到内存。这时候，能够体现B树的多路存储作用，每次加载B树的一个结点，然后一步一步往下找。</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714091.png" alt="image-20220925163551755"></p><p>假设内存一次性只能加载两个树，这时候有序数组【25，25，30，40，43，45，50，59，65，77，85】是不能够一次性加载到内存的，所以，可以构建三路B树，每个结点至多有两个数。</p><p>那<strong>B+树</strong>有什么作用？</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251714422.png" alt="image-20220925164941429"></p><p>这是一棵4路B+树，<strong>数据都在叶子结点，并且通过链表相连</strong>。</p><p>使用场景：比如select查询多条数据，B树可能需要做中序遍历，跨层访问，而B+树所有的数据都在叶子结点，同时拥有链表结构，只需要找到首尾，就可以把所有数据取出来。</p><p>mysql存储索引使用的是B+树。</p><p>B+树查询效率与树的高度有关，O(logn),而hash查询索引效率O(1),hash比B+树更快，为什么要用B+树，而不用hash?</p><p>1.只查询一个数据，确实是hash更快，单数据库经常查询的是多条数据，这时候B+树索引有序，又有链表相连，查询效率要比hash快很多。2.前面提到，数据库索引一般存储在磁盘，如果数据量大，一次可能无法装入内存，B+树可以分批加载，树的高度越低，可以提高查询效率。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉排序树 </tag>
            
            <tag> AVL </tag>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文系列</title>
      <link href="/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/"/>
      <url>/2022/09/25/%E5%9B%9E%E6%96%87%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<ul><li>寻找回文串  –&gt; 双指针从两端向中间逼近</li><li>寻找一个字符串中最大回文串  –&gt; 寻找以s[left]和s[right]为中心的最长回文串  （中间向两端逼近）</li></ul><h1 id="判断回文单链表"><a href="#判断回文单链表" class="headerlink" title="判断回文单链表"></a>判断回文单链表</h1><p>思路1：反转单链表，判断两个链表是否完全相同</p><p>如何反转单链表？ <a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></p><ol><li><p>依靠栈</p></li><li><p>头插法，把原链表一个一个摘下，插入到新链表前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p=head.next;</span><br><span class="line">    ListNode pre=head;</span><br><span class="line">    pre.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        ListNode s=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">        s.next=pre;</span><br><span class="line">        pre=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归</p></li></ol><blockquote><p>递归的空间复杂度为O(N),而迭代的时间复杂度为O(1).</p></blockquote><h2 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h2><p><strong>==递归最重要的就是明确递归函数的含义==</strong></p><p>ListNode reverse(ListNode head) // 输入单链表头结点，将该头结点的整个链表反转，返回新的头结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251122515.png" alt="image-20220925112218962"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">ReverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=ReverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方式，代码简洁优雅</p><h2 id="递归反转部分链表"><a href="#递归反转部分链表" class="headerlink" title="递归反转部分链表"></a>递归反转部分链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></p><p>reverseBetween(ListNode head, int left, int right) //输入单链表头结点，将链表的第left结点到第right结点反转，返回新链表的头结点</p><p>首先，考虑如何反转前n个结点</p><p><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209251152986.png" alt="image-20220925115211597"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ListNode successor=<span class="literal">null</span>; </span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head，<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        successor=head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode last=reverseN(head.next,n-<span class="number">1</span>);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：递归反转部分链表</p><p>left=1 就想当于反转前n个结点</p><p>left!=1 前进到反转的起点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head,right);</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=reverseBetween(head.next,left-<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文串 </tag>
            
            <tag> 反转单链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法</title>
      <link href="/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    HashMap&lt;<span class="type">int</span>,<span class="type">char</span>&gt; map;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>; <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;s.length)&#123;</span><br><span class="line">        <span class="comment">// 将该字符移入窗口</span></span><br><span class="line">        <span class="type">char</span> c=s[right];</span><br><span class="line">        right++; <span class="comment">//增大窗口</span></span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">    <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        left++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：力扣第 76 题「 <a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a>」</p><p>思路：</p><ol><li>初始化左右指针left=right=0; 把[left,right) 左闭右开，作为窗口</li><li>不断增大right指针，直到窗口中的字符串符合要求（包含T中所有字符），停止增加right  ——&gt;寻找可行解</li><li>增大left指针，缩小窗口，直到窗口的字符串不再符合要求（不包含T中所有字符），停止增加left –&gt;这个可行解的最优解</li><li>重复第2第3步，直到right到达字符串的尽头  –&gt;最优解</li></ol><p>HashMap中记录窗口中的字符和需要凑齐的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录目标字符串，每个字符及对应需要的个数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need.get(t.charAt(i))==<span class="literal">null</span>)&#123;</span><br><span class="line">                need.put(t.charAt(i),<span class="number">1</span>);</span><br><span class="line">                window.put(t.charAt(i),<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                need.put(t.charAt(i),need.get(t.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> valid=<span class="number">0</span>;<span class="comment">//窗口需要满足的字符个数</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;<span class="type">int</span> end=s.length()+<span class="number">1</span>;  <span class="comment">// 记录最优字符的起始位置</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">char</span> c= s.charAt(right); <span class="comment">//加入窗口</span></span><br><span class="line">             right++;  <span class="comment">//扩大窗口</span></span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">                window.put(c,window.get(c)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(window.get(c).equals(need.get(c)))&#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(valid==need.size())&#123; </span><br><span class="line">                <span class="comment">// 寻找可行解的最优解</span></span><br><span class="line">                <span class="keyword">if</span>(end-start&gt;right-left)&#123;</span><br><span class="line">                    start=left;</span><br><span class="line">                    end=right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d=s.charAt(left); <span class="comment">//移除窗口</span></span><br><span class="line">                left++;  <span class="comment">//缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(window.containsKey(d))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(window.get(d).equals(need.get(d)))&#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d,window.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end-start==s.length()+<span class="number">1</span>?<span class="string">&quot;&quot;</span>:s.substring(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 语言处理字符串还是有点麻烦的，一直使用charAt(i)  没有使用索引s[i]方便</p><p>同类型练习题</p><p>力扣第 567 题「 <a href="https://leetcode.cn/problems/permutation-in-string/">字符串的排列</a>」   维护的滑动窗口定长</p><p>力扣第 438 题「 <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a>」</p><p>力扣第 3 题「 <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a>」  还没做</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的字符串类</title>
      <link href="/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
      <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="String-不可变的字符串"><a href="#String-不可变的字符串" class="headerlink" title="String 不可变的字符串"></a>String 不可变的字符串</h2><p>String类部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="comment">// 可序列化</span></span><br><span class="line">    <span class="comment">// 可比较大小</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];  <span class="comment">//数组元素不可修改（final）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">        str.getChars(buf, len);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>String类被定义成final,不能被扩展，也不需要被扩展（定义的方法很全）。</li><li>用char数组来存储，并定义成final，<strong>不可变</strong>。</li><li>对字符串操作，不改变原字符串，都是new String()。</li></ul><img src="https://cdn.jsdelivr.net/gh/shatianhui/mypictures/img/202209231515205.png" alt="image-20220421094420345" style="zoom:67%;" /><p>intern():如果字符串常量池中包含一个等于String对象的字符串（通过equals()）,则返回池中的字符串，否则，将String对象添加到池中，并返回该对象的引用。由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为真时，s.intern() == t.intern() 才为真。</p><h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>StringBuilder部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence&#123;</span><br><span class="line">    <span class="type">char</span>[] value;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保存数据的char数组并未被定义成final</li><li>可变字符序列</li></ul><blockquote><ul><li>String是不可变字符序列，而StringBuffer，StringBuilder都是可变字符序列</li><li>String可以通过字面量方式赋值，StringBuffer/StringBuilder只能是通过构造器 new</li><li>StringBuffer线程安全，效率低（里面的方法都是synchronized,同步方法），而StringBuilder线程不安全的，效率高</li></ul></blockquote><p>三者底层都是使用char[]数组进行存储，那如何实现可变和不可变？</p><blockquote><p><code>String s=new String()</code> //new char[0],长度为0</p><p><code>String s=new String(&quot;abc&quot;)</code> //new char[3]{‘a’,’b’,’c’}</p><p><code>StringBuffer buffer=new StringBuffer()</code>// new char[capacity]   capacity=16</p><p><code>StringBuffer buffer1=new StringBuffer(&quot;abc&quot;)</code>// new char[s.length()+capacity]   capacity=16  capacity+s.length()作为初始容量，然后调用buffer.append()   （看一下如何进行扩容）</p><p>问题1：此时buffer1.length()  是3    //append()后count+buffer1.length()返回count的值，而不是数组的容量</p><p>问题2：char数组如何进行扩容？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;   <span class="comment">//确保容量是够的</span></span><br><span class="line">  <span class="comment">// minimumCapacity是count+append的字符长度</span></span><br><span class="line"> <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;<span class="comment">//大于数组长度，不够了，需要扩容</span></span><br><span class="line">     value = Arrays.copyOf(value,</span><br><span class="line">                           newCapacity(minimumCapacity));<span class="comment">//默认下，扩充的容量是2倍的value+2</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//int newCapacity = (value.length &lt;&lt; 1) + 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>如果append次数很多，频繁扩容，扩容要复制一份，影响效率，所以可以使用<code>StringBuffer(int capacity)</code>构造器,指定容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟 String做对比</span></span><br><span class="line">StringBuffer buffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">buffer.setCharAt(<span class="number">1</span>,<span class="string">&#x27;m&#x27;</span>);<span class="comment">//void方法，没有返回值</span></span><br><span class="line">System.out.println(buffer);<span class="comment">//amc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaSE学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串不可变性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
